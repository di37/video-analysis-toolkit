{
  "id": "5eed1df6-2c9b-4003-8a89-ea9900963aa0",
  "content": "Okay. So let's get started with today's lecture. Today is day nine of this boot camp and we have two more lectures now remaining. This lecture and one last lecture which will be held tomorrow. So today we are going to learn about another AI agentic framework and that framework is called as AI. So first let me ask how many of you have heard about CRAI or have used it. I can see in the chat that many of you have heard it. Some of you may not have heard it but this framework has become really very popular in the last couple of months and it's I'll explain the reason for its popularity today. how it differs from the rest of the frameworks which we have learned in this boot camp and today we are going to code two projects using the CEI framework which you can add to the list of projects you completed during this boot camp. Today's lecture is also not going to be as complex as the last two lectures. So the last two lectures which we had agentic rag and langraph were quite intense. Both of these lectures were around 100 minutes long. um because both of these involve coding frameworks. Today we are going to deal with a low code framework which is CRAI and I'll also explain why I call it low code. Um so this lecture is going to be easier compared to the previous two lectures. Before we get started with CUI, let me do a quick recap of what all we have covered in this boot camp so far. And if you are on the pro plan, you should definitely go through all the Substack articles which have been published because those are directly related to the boot camp content. So for example, this is the first Substack article that's about day number one of the boot camp where we studied about LLM agents, agency of agents and main papers which have given rise to the field of agents. Then is the day two of the boot camp where we studied about large language models. So day number one and day number two were introductory uh lectures understanding agents and language models. Day number three is when we learned about the thought action and observation framework. So this is one thing which should always remain in all of your minds after this boot camp is over. Even if you forget many things, this thought action observation loop is at the heart of what makes agents really very different from language models. They due to this loop, agents can plan, they can make decisions and they can also interact with the external environment. And again in lecture number one, we have covered the definition of an agent. So never forget this definition. Agents take you from point A to point B and they add value to your life. They can plan, take decisions. They have access to tools. They can also interact with the environment and have memory. And the underlying foundation of agents is language models. And in day number four, we looked at an overview of the types of frameworks, the coding frameworks, the low code frameworks, and the no code platforms. And in coding frameworks, we have covered langraph, llama index and small agents. We have had lectures on all of these three topics. in low code frameworks. Today we are going to learn about Crave AI and tomorrow you are going to learn about NAT. And then we actually had two lectures on small agents. In the first lecture we covered uh tool calling agent versus code agent, vision agents and in this lecture we also looked at lang fuse actually. So just read through the Substack article of this lecture to see what we covered on day number five. On day number six, we built multi- aent systems using small agents. And this was our first time where we understood the difference between just having one agent and giving it all the tools versus having multiple agents such as a manager agent managing a group of agents. And we saw that this leads to better memory division. It leads to better answers. And this also leads to efficient token usage. This was essentially day number six. And in day number seven and day number eight we covered two major frameworks. We covered llama index in day number seven. And here we understood the agentic rag framework. Um so we first looked at what exactly is retrieval augmented generation. The steps for implementing rag and we ran a code for this. After this we saw the limitations of rag. Essentially it's just oneshot retrieval and generation limited to one knowledge source. No use of external tools etc. And then we learned about agentic rag which goes into this loop. Through learning about rag versus agentic rag we also learned about llama index which was my purpose of this lecture to get you familiar with llama index as well. Um and finally at the end of this lecture we also learned about arise phoenix which is another framework apart from langfuse which can be used for tracing and evaluation. Last lecture was probably the most complex lecture of this boot camp where we learned about lang graph. We first saw the limitations of lang chain. Then when to use lang chain versus lang graph then we saw the nees framework nodes edges and states and we learned about what exactly these foundational principles mean. And then based on that we built an email sorting agent. That's the first thing we did in the previous lecture. And after that we also built a vision assistant agent. This I showed you in two parts. First we built a simple vision assistant agent where I showed you this loop between assistant and tools. That's essentially the thought action observation loop which makes agent special. And then I I also shared one more code with all of you at the end of the last lecture through which you can add tools such as an email sending tool. I continued to use langfuse throughout the duration of this boot camp. Now we won't be using for the last two lectures. We won't be using any evaluation framework but in three lectures of this boot camp we have now used some sort of an evaluation framework either it's langfuse or Phoenix and again when I say evaluation I mean observation plus evaluation both things are equally important observation is cheaper and can be done faster evaluation is intensive and you can either do human evaluation or using LLM as a judge that type of an evaluation both of these evaluations are possible to set set up in Langfuse. Uh I have also I've also shown you how to set up an evaluation dashboard in Langfuse. So yesterday we saw this tools assistant thought action observation loop in action once more and this is where we are right now. So the reason I covered this recap is just for you all of you to have a understanding of what all has been covered uh in this boot camp so far. So it sets the context for the last two lectures. Now in the remaining two lectures I want to cover some modern frameworks which are actually simpler than what all we have seen so far. Um but the previous lectures were important so that you can appreciate why these tools have become so popular. So let's start with the first tool which is create a now in langraph we I had to show you so much theory right before we started jumping into code. One advantage of CRU AI is that it's actually an extremely simple framework. Um but still there are some foundational building blocks of this framework which are important. So essentially to define agents in CI you need to define three things and the way I remember it is C A T. So first is agent you need to define agents. You need to define the task which the agents perform and then you need to define a CRU. So CRU is essentially a group right. So that's why it's called CU AI and just as the name suggests this framework has become extremely popular for um for developing or for building multiple agents which run together and I'll show you why. But the reason it's called Creoa is because you can assemble a group of agents together um in a very efficient manner using this framework. So today we are going to do two projects. First is we are going to create a multi-agent CRUI framework to research and write an article and the second project is we are going to build a customer outreach campaign agent using CUI. Now as we are building these projects just remember that we have already done a multi- aent code. If you remember this was our multi- aent code where we had uh the manager agent and where we plotted the Harry Potter locations and the cricket stadium locations. You remember this was the entire code which we assembled. So here is where we split the task between two agents. We defined the web agent over here and we defined the manager agent over here and ultimately it looked something like this. So there were some steps involved to define this multi- aent framework but we did define it successfully. So then you might be thinking that if I can do multi- aent frameworks using u previous coding libraries then why do I need crewi in the first place and I hope that when we go to the Google collab code file the answer will be self-explanatory. So let's start actually creating this this first project which is uh creating a multi- aent clea framework to research and write an article. Now as I mentioned the first step to create a CRU is this CAT framework right CRU agent and task. First we have to define an agent. So let me mark this with a different color. First we have to define an agent. Then we have to define the tasks which every agent will do and then we have to assemble a crew out of all of these agents which we eventually define. Now uh when you define an agent in preair you have to essentially define three things and the way I remember this is R G and B. So you can think red green blue but R stands for role G stands for goal and B stands for backstory. So when you define an agent in CEI you have to mention the role of this agent you have to mention the goal and you have to mention a backstory. The way we are going to create this multi- aent crea framework to research and write an article is that we are going to have three agents. We are going to have a planner agent. We are going to have a writer agent and we are going to have an editor agent. These are the three agents. And when we jump into code, we'll write all of these three descriptions for the three agents. We'll write a role, goal, and a backstory for the planner agent. We'll write a role, a goal, and a backstory for the writer agent. and we'll write a role goal and a backstory for the editor agent. So the planner as you can see it's already quite intuitive right the planner will plan for what you want to write the writer will write a first draft the editor will edit that draft and give the final article to you this framework once we make it you can already start using for making LinkedIn posts uh for making substack articles anything let's say which you want to monetize later this can entirely automate that workflow for you once we define these three agents we don't have to stop here we We have to define the tasks which each of these agents will do. So when we define tasks for every agent which we have defined over here, we need to define the description of the task. We need to define the expected outcome and of course we have to define the agent name. So if it's a planner, we have to mention what's the description of the planner agent, what's the expected outcome. If it's a writer agent, we have to mention the description and expected outcome. And similarly for the editor agent and finally it all comes together when we assemble the crew. So when we assemble the crew we have to mention the agents which we have we have to mention the tasks which we have and the most important thing I believe which makes Cre very special is this workflow. Um but before I get to the workflow all of you can see this and you can see that it's so intuitive right? This is exactly how we think in English language how we can do tasks using these agents. So you first assemble three agents you mention the tasks which they want to do and then you form a crew of these three agents. That's it. And once you have this kind of a framework of crei in mind writing the code actually is straightforward. Before we jump into code, I want to mention that thing which makes CRAI very special and that thing is that you can actually define various types of workflows using CRAI. Essentially there are five workflows which you can define and I'm going to explain all of these. First is a sequential workflow. Second is a hierarchical workflow. Third is a hybrid workflow. Fourth is a parallel workflow and fifth is an a sync workflow. Um so you can assemble all of these agents in any manner which you want and already you can start visualizing right what might be the differences between these sequential agents are ones which we have seen before. The first agent does a task it hands it over to the next agent. The next agent does a task and it hands it over to the next agent. Hierarchical agent is something different. So there is essentially a manager agent which manages two agents. So the task is received by this agent and then this agent decides whom to give the task to there is no pre-planned sequence like in sequential agent that's hierarchal agent. Hybrid agent is where you have mix of hierarchal hierarchical plus sequential. So this part is hierarchical and this part is sequential. That's hybrid. Parallel is when you want multiple agents to be working in parallel at the same time. So let's say if there are thousand research documents you can spawn or you can start five agents together each of which can handle 200 documents in parallel and then you merge those results together. A sync is when basically each task is executed independently. So every agent outputs something at a frequent at frequent intervals of time without waiting for a completion from the previous agent. So this sequential is also a synchronous task because after the first agent finishes then only the second agent can start but a sync is an a synchronous task which means every agent is essentially working independently. So this first you can think of like a relay race after the first agent finishes it hands over the bat to the next which hands over the bat to the next etc. So again here I have mentioned the uh the flow type the explanation and a simple example. So if you compare sequential versus hierarchical in sequential agent A writes content agent B edits it whereas in hierarchical a manager agent assign tasks to two employees and then two employees are agents which do those task. That's a hierarchy. Um hybrid is essentially a mix of sequential and hierarchical. So a leader assigns tasks to two agents and then each of those two agents you have a sequential workflow. Let's say that can be called as an hybrid uh hybrid approach of a multi- aent framework. Parallel is as I mentioned two agents independently research topics at the same time and async is synchronous. So agents post updates periodically regardless of other tasks. So in synchronous frameworks tasks are tasks are executed independently without essentially waiting for completion. Now you don't have to write any different code if you want any of these workflows to happen. You just mention it over here. When you define the cube, you just mention the type of workflow which you want. Whether you want it to be hierarchical, whether you want it to be sequential, whether you want it to be hybrid, parallel or a synchronous. It's that easy. In you can easily define the type of multi- aent orchestration which you want. So putting different agents together is also called orchestrating agents. So this process of defining the way you want different agents to work is called orchestration. And you can think of it like an orchestra, right? Let's say there are different musicians playing instruments. The order in which the musicians play that can change and that needs to be defined. So it's similar here. You need to define which agents does its task at what time. Does it depend on previous agents? Does it not? Etc. So that's to be decided by the user who writes the threewayi framework. Um so until now what I have mentioned is theory. Now let's dive into code. So I'm going to share a code file now with all of you. So let me yeah let me share this now. So again I'm making a copy of this Yeah. So, I've shared this uh code file with all of you in the chat. Now, I would request you all to open this and let's start running the code file together. So essentially now what I'm going to demonstrate is what I have written in English language over here on the whiteboard is exactly how we are going to write this code. To execute this you will need one thing which is the open AI API key. So just paste your openi API key in this place where I have pasted mine over here. Um so here is where you need to paste your open API key this place over here and actually that's the only thing which you will need to be able to uh execute this code. So let's start running it together. So one thing is important is that to install CI you need to have Python greater than or equal to 3.10 otherwise it will not be installed on your system. So here is the main command where you are installing CI. So I'm doing pip install CI over here. It will show uh that install is not defined but still the the package actually does install. So don't worry if it shows this red line over here. It will take some time to install the package but again it's not very heavy. So um it should it should install relatively quickly for all of you. Can you just mention if anyone has finished installing this package? You can share yes in the chat. I'll just wait till that much amount of time for us to proceed. So I can see that many people have already finished installing the package. Um okay for me it's taking some time over here. So I'm waiting over here. But others who have actually finished this you can start sequentially executing the rest of the code. So for me also it's done now. So I've installed CI and I'm moving forward now. So the reason I have showed this Google collab in black color today versus the light background is because the C AI output which is there it's it does not look very good in a light background. So that's why I have opened this Google collab in a dark theme today. Yeah. So as I mentioned you have to define three things right. That's the cat cat framework which we saw agent task and crew. This is exactly what we are doing over here. We have to do from crew AI we have to import the agent task and the crew and you have to run this run the open AI key and as I mentioned on the whiteboard for every agent essentially remember agent task and crew right. So first we have to define agents as we saw over here and for every agent you have to define a role a goal and a backstory. So that's RGB. Similarly here I have mentioned that for every agent we have to define a role which is the agent's function within the crew. Goal which is the objective of the agent and backstory provides context to the agents role and goal. So in this code file I I'll also show you the importance of writing prompts in as much detail as you can. So the way you define agents in cura is as simple as this. First you have to define a planner agent. Right? So this exactly looks almost like English language. Right? You don't have to assemble any complex piece of code. Here what I'm doing is I'm defining a planner agent and I'm mentioning the role goal and the backstory. So I'm mentioning that the role of this uh the role of this agent over here is content planner. The goal is plan engaging and factually accurate content on the given topic. I'll tell you where this topic actually comes from. And the backstory is you are working on planning a blog article about this topic. You collect information that helps the audience learn something and make informed decisions. your work is going to be the basis for the content writer to write an article on this topic. So it is basically the backstory for the planner agent and here I have mentioned allow delegation equal to false. So this is again that thing of sequential workflow. So I want a sequential workflow over here. I'm not allowing this agent to delegate its task to anyone. So you run this and that's the planner agent which is defined. As we saw we are going to define three agents right planner, the writer and the editor. So the next step is you have to define the writer agent. So here again you write the role, the goal and the backstory. The role is again content writer. Goal is to write an insightful and factually accurate opinion piece about a topic. And then backstory is this. You're working on a writing a new opinion piece about this topic. You base your writing on the work of the content planner who provides an outline. So again, this is like a relay race, right? The bat is now passed from the content planner to the content writer. You follow the main objectives and direction of the outline. You also provide objective and impartial insights. You acknowledge in your opinion piece when your statements are uh opinions as opposed to objective statements. See now some amount of time has been spent on writing these prompts. Technically, you can spend more time also writing these prompts, but already it's a bit detailed. So, the reason I'm mentioning this to all of you is because the prompt is probably very important and not many people spend a lot of time thinking about the way you write these things. So, this looks pretty simple, but you can be lazy and write it in a very short manner. You can make use AI to write these prompts but then you have to make sure that it actually it's it it should not be blind use of an AI tool. You should actually write what you're feeling. So imagine you are writing this piece, right? If you care about writing the piece nicely, that will come in your prompt nicely. And longer prompt does not mean a better prompt. Not at all. In fact, it goes the reverse way. Sometimes if you make the prompt very elaborate, the LLM will not understand which parts of the prompt to pay attention to and which part to not pay attention to. So you have to don't just keep writing the prompt randomly. You have to make sure that the prompt is concise enough but it should it should not be written lazily also. You have to strike that balance. Um okay. So now next is the third agent is the writer agent. Right? Actually writer agent is is done. The third agent is the editor agent. So content planner, writer and editor. The editor agent is the final final agent. So the editor agent edits a given blog post to align with the writing style of the organization. You are an editor who receives a blog post from the content writer. Your goal is to review the blog post and provide balanced viewpoints. We can also add some things like make sure that the grammar is correct and make sure that uh nothing is wrong over here etc. So then you run this over here. So then there are three agents the planner agent the writer agent and the editor agent which have been defined. That's the first step of crewi define the agent. The next step is task. So you might be thinking didn't we already define the task over here? So we did not actually if you see the way we have defined the agent we have only mentioned the goal we have not mentioned the tasks the task is also usually where we can give access to tools. So in the second project which we are going to run today I'll show you how to give access to tools when you write the task. The tools are not passed in the agent description itself. The tools are passed when you define the task. So the next step is defining the task. And as I mentioned in the task you have to define three things. You have to mention the description of the task. You have to mention the expected outcome. And you also have to mention the agent um who is doing the work. So the first task is plan right. And uh this is the the agent which is doing the work is the planner agent. So I have mentioned agent equal to planner. Description is prioritize the latest trends, key players and noteworthy news on the topic. Identify the target audience. Developed develop a detailed content outline. Include SEO keywords and relevant data. That's the description. Expected outcome is comprehensive content plan document with an outline, audience analysis, SEO keywords and resources. That's the planning task. Then we have the writing task. Here the agent is the writer agent. And here we mention use the content plan to craft a compelling blog post. Um mention section subtitles. Make sure they are properly named. Ensure the post is structured with an engaging introduction, insightful body and a conclusion. Proofread for grammatical errors. And then expected output. Here you also mention how long you want the blog to be a well-written blog post in markdown format. So if any of you write blog writes blogs over here, this agentic framework which we are building right now, it can be the first draft which you can just copy paste and then make minor edits. But here is where you have to write typically how long your blogs are. Is it two to three paragraphs? Is it more than that? Etc. What is the expected outcome out of the writing agent? That's the second thing. The third task is editing. Right? So in the third task, what you have to do is that you have to proofread the blog post for errors uh for grammatical errors. Right? So and this we cannot write in the agent description itself. It's much better to write it in the task and then the expected outcome is a well-written blog post. Each section should have two to three paragraphs. So here again we maintain the length which we want of the final blog post. And then now that we have defined the agent, we have defined the task. The last step which is left for us is to assemble the crew. So that's exactly what we are going to do right now. Let me actually run this. Let me run the the planning task, the writing task and the editing task. And now we have to form the crew. When you form the crew, you just have to mention the tasks, the agents and the workflow. So here I'm forming the crew here. And if you don't mention any workflow, it will by default enter into a sequential workflow. So here what I've done is see this process, you have to mention the tasks, you have to maintain mention agents and the process. So by default the process is a sequential process but here you can mention the type of process which you want. So uh here finally this is the place where you define the crew and uh tasks agents. So the tasks are planning, writing and editing and the agents are planner, writer and editor. That's it. So did you see now we have defined the crew right? Did you see until now what we have written on Google collab is not that different compared to what we have written on the miro whiteboard. In fact here it almost feels like we are writing in English language. It does not feel like we are coding at all. That's one of the biggest advantages of CUI and that's the reason I call it a low code framework because compared to this remember this was our coding based framework when we wrote about the multi- aents and here it actually felt as if we are writing code and for those people let's say for people who want quick prototypes and who don't want to get into coding frameworks seems like a much better and an intuitive approach for easily chaining multiple agents together because even to define the crew it just assembling the tasks agents that's it. And now once the crew is defined the way to actually activate the crew is something called kickoff. The way to activate the crew is you do crew. Kickoff. So remember first of all we are using this topic various at various places right in the planning we use the topic when we define the planning agent also we use the topic the topic is provided over here so you when you do creo.kickoff kickoff you can actually provide the input topic. So I have put the topic as artificial intelligence. So we expect a blog around artificial intelligence in three stages planning, writing and editing. So now let's see this agent in action. So I've run this right now and here you can see the agent is content planner and these are the four tasks which this agent um has started to do as we have run this code snippet. So the output of CUI is so good that it's actually very easy to parse. So right now you can see that the content planner has finished and this is the final answer of the content planner. It has mentioned the latest trends in AI, key players in the AI space, target audience analysis, content outline um and it has aggregated its answer into this kind of paragraphs. Right? So this is this is the first agent which is the planner and then you have the second agent which is the content writer and the content writer has the content plan and it has to now write a post based on whatever the plan has been received and this is the final output of the content writer. We instructed it to make it markdown. So that's why it's marked down over here and this is what the content writer has written. But our multi-agent framework won't stop here. The third agent which we have in the sequential workflow is the editor and the editor's task is to proofread the given blog post for grammatical errors and alignment with the brand's voice. And so this is the final editor answer. Now the editor would have verified the grammatical errors and kept the paragraph length to whatever you wanted and then you can just print the markdown. So see now we have an entire blog post which we can directly copy and we can paste into any kind of blog or any kind of article which you are writing and next time you when you want to generate a new blog post all you have to do is that you have to change the topic over here and a new blog post will be generated. This is how you can completely automate your postw writing workflow and you can make it as tailored as you want. You can even add images. The way you can add images is that you'll need to pass in tools and I in the next project which we are going to do I'm going to show you how to add tools uh to task descriptions. So if you want your blog post to have images you just pass in a language model which is a multimodel language model which can generate images. Um so now instead of writing every single blog article from scratch that's one way. The second way is blindly copying everything from chat GPT. But Creai provides a framework in the middle, right? Where you can personalize the content exactly as per you want. You can chain multiple agents together. You can make sure that every single task is done correctly before getting the final answer. And if you have a marketing, if you are in marketing or if you have marketing agency or if you just want to build your brand online, this is just an amazing fast workflow for you to do that. This will not be your final blog of course, but it will save you a huge amount of time because then you just have to probably edit this, make sure some sections are as you wanted it, etc. Uh, how many of you have finished this part? Can you type yes in the chat if you have finished? running this workflow and you can see right already that this is much simpler compared to lang graph this is also much simpler compared to small agents multi- aent framework that's why creai is very good for building simple prototypes if you are in enterprise setting and ultimately want to deploy some agent again lang graph is preferred because it gives you more control but for developing initial prototypes for showing it to client Friends, CRU AI can be actually a much faster alternative for all of you. So, let me pause here for a moment and ask if there are any doubts or any questions over here. Uh, by generating AI content, are we not going to plateau quickly and also result in overfitting? So basically generating AI content can be done in multiple ways right you can use agents and you can use let's say chat GPT if you are using chat GPT I agree you're just recycling previous information but these agentic systems actually allow you to add personalization on your own so that way it's not I would say it's not recycling that much if prototyping with CRA how to convert it into lang graph for production that's a good question so directly you cannot convert this into lang graph for production but this will give you a sequence which actually works so for example now that this result is actually good what you can do is that you know which agents how many agents do you need uh in which sequence do you need then you can take this and migrate it to lang graph there you you'll have to write a separate code but at least you know how many agents you need what's the prompt every agent requires etc. So then many things can be replicated. Now if you want to do in lang graph yeah as I can see in the chat that would be an interesting exercise how to do this in lang graph. So let's all try to think about this right. How would we do this exercise in lang graph? First we have to decide the state. The state is the article the way it is written at any given point of time. That would be the state. The nodes the nodes will be the different functions. The first node would be um planning. The second node would be u writing. The third node will be editing. That's it. So it will be a simple sequential graph in this case. Is it possible to create agentic loops in this case? Um so the thing is by default the way these agents are written they will go in a loop. So when I have I have mentioned three agents right the way CUAI has internally defined these agents is that they will be based on the thought action observation framework. So the loops are by default integrated in this approach. If I want to make chatbot with the help of this then how to make it? So remember that what is a chatbot? Think about it in terms of tools right in if you want to make a chatbot using this approach what tools will you give? You will need a language model definitely you will probably need a query engine. So those you have to you have to mention it in the tools over here. If you want to give the query engine as a tool just mention the tool over here which you want. Um a language model definitely has to be a tool. So mention think about the different types of agents which you will need. Think about the different types of tasks and then just assemble the crew. Can we see how agents are internally communicated in Creai? That's a good question. So I will share this material with all of you on discord. Right now I won't cover it in today's class because that's a very extensive material. But for those of you who are interested I will share so that you can see the internal workings. Probably I'll take one or two more questions and then we can go to the next project. Where are we defining the order in which the agents are running? So there are actually two two things which we are doing right. So if you see the order with which no not this code this code the order in which we are running the agents is over here. So the tasks right plan comma write comma edit. So by default this is this is the order in which the agents are running also it's a sequential workflow workflow. So in the right we have mentioned that you have to take input from plan. In the edit we have to we have mentioned that you have to take input from right. And one more place where we are mentioning this sequences over here. Not explicitly but since we have not mentioned any process by default it will follow the sequential workflow from planning to writing to editing. Okay. So now let's go to the next uh next project. Next project which we are going to build is a slightly more complex project which is um customer outreach campaign. So here what we are going to do is that imagine you are a company right and you have a certain product one common task for all companies who are product based companies or service based companies either either of which the common task is to reach to customer profiles first to identify customer profiles and to send email to them. This is also called outbound marketing by the way or outbound emails. So this every company has such kind of an outbound strategy which is usually very very useful in sales. And this is one project which we saw in our first lecture how to automate um outbound sales strategies. So let's see actually how to do this. And again we are we'll use the same framework. We'll use the agent task and the cube. The agents which we are going to use are two agents. First is a sales representative agent and second is a lead sales representative agent. The sales representative agent will do something which is called as lead profiling. Which means the sales rep agent will gather more information about the lead and then pass this information to the lead sales representative agent. the lead sales representative agent will draft the personalized email and then we'll send it to that potential client. So this is the workflow which you are automating right now. And now in in the tasks we'll need tools right to find the people or let's say when you have a lead to find more information about their company what's the mission of this company you'll need all that information to draft the email. The way you will get that information is using a tool called serper and we have already seen this before. We have used the serper tool before. This is one more time where we are going to use it. Then we need the directory read. Then we need file read. Basically we can go to any directory, open a directory, open a file, read the file etc. This will make sure that we get the details about a particular company so that we can draft a personalized email. And not just that, we are also going to build a customized tool in this project. So you will see that CUAI offers its own array of tools by default. So we'll have simple functions to define these tools that's offered by CI itself. But if you want to define your own tool, I'm also going to show you how you can define your tool. So then ultimately our toolkit will combine these three tools and our customized tool that will be the four uh tools which are assembled in our toolkit and then finally we'll form the crew. So again this will be a sequential crew crew from the sales representative agent to the lead sales representative agent and finally the email will be drafted. But we'll use these tools. Again, as I mentioned earlier, tools are not to be defined here. They are only to be defined in the task. So now I'm going to share another code file with all of you which is our second project for today. Okay. So now my code file is ready. Let me share it with you. Yeah, this is the uh this is the second this is the second code file. So let's take a look at this right now together. So this is the code file for the customer outreach campaign. And before running this file actually it's very similar to the previous code but we'll need uh two things. We'll need the open API key and we'll need the serer API key. So here is my original file where I have the open API key and I have the serper API key as well. Again to demonstrate how to get the serper API, you just go to serper.dev uh and then you click on sign in. If you all of you should already have an account because we have used this before. If you already have your key, you can directly use this. How many of you still have your serer key can you mention in the chat? If you not if you don't have it, we need to create it once more. Okay, I can see that three to four people have mentioned that they do have your keys, right? We have created it before. So just copy that. But if you don't have it, you you can sign up over here. You can create your account and you'll directly get the key. You can use it for free. This this does not require any charge or any payment at the moment. Okay. So once you have this then we are ready for making we are ready uh to assemble this entire crew. So now let's start running this together. The initial steps remain exactly the same. So they might take a bit of time. First we have to mention we have to install CRI but in this code we also have to install CI tools because we are going to use some default tools which are provided through the CI library itself which were not this we did not use in the previous uh previous Google collab code because we did not use tools really but now we have to use this pip install create tools. So these three commands will take some time. Then the same thing we have to from treei we have to import the agent we have to import the task and we have to import the cre. So you can run this and then you have to write down the API keys. So this is the open API key. This is the serer API key and this is the openi model name. You have to run this and then now start forming patterns in your mind because now what I'm showing is exactly what we have done before right uh what are the steps agents task and crew three steps and in agents we have to mention role goal and backstory so since we have two agents here sales rep agent and lead sales representative agent these are the two agents which we have so let's define their role their goal and the backstory So this is a sales rep agent. Now role is sales representative. Goal is identify high value leads that match our ideal customer profile and backstory as as part of the dynamic sales team at Crea. So you can assume any company which you want. Your mission is to scour the digital landscape for potential leads. Armed with cuttingedge tools and a strategic mindset, you analyze data, trends, and interactions to get opportunities that others might overlook. your work is crucial in paving the way for meaningful engagement and driving the company's growth. Um, okay. That's my my first agent, sales representative agent. And my lead sales representative agent has a much higher or much bigger uh responsibility. Their goal is to nurture leads with personalized compelling communications. So within the vibrant ecosystem of Crea sales department, you stand out stand out as the bridge between potential clients and the solutions they need. By creating engaging personalized messages, you not only inform leads about our offerings but also make them feel feel seen and heard. Your role is pivotal in converting interest into action. So these prompts have been generated through chat GPT but not directly. A lot of customization has been done to get these prompts. So some keywords which have been used are make it compact, make it concise but make sure it achieves the main objective of the lead sales representative and the main objective is to nurture leads with personalized compelling communication. There is also a question of how to choose the model name. So it depends here you can even go with 3.5 actually because here we simply want to do writing tasks right but if you want to have multimodel functionalities so if you want to even create and add images then you can go ahead with 40 or some um um other a bit more advanced model the latest one is GPT 4.1 which you can use if you are using or if you're deploying in industry setting Um can you please explain this example by relating to thought action observation and agentic rag. So first of all agentic rag is not even in the picture here because we don't have any documents to query from and thought action observation loop is coming in the back end. So one disadvantage you can say about create is that everything looks very simple right? So that's why people have all of these questions that where is the agent actually operating but the way now when you write agent over here that's the abstraction the way they have coded it in the back end is such that when you write this agent here and when you invoke the agent it will automatically go into the thought action observation framework which is uh which is prescribed by react but that depends on the way they have written this functionality um and Actually there is a question on how LLM is passed here right you can use you can define the LLM here but if you don't define any LLM uh the code will automatically pick the language model which is in your environment so in my environment it's open AI right now so by default this language model and this key is picked but if you want to use different LLMs for different agents you can mention an LLM also when you define uh when you define an agent now the next step. Now this step number four play pay careful attention here because in the previous in the previous code we directly jumped from agent to tasks but now we are going from agents to tools and then from tools to tasks. So there is one more step which is added. So as I mentioned before we are going to use these three tools serer tool, the directory read tool and the file read tool. These three tools we are going to use from uh CI tools itself. So here you can see from tools you can import these three tools. Directory read tool, file read tool and serere dev tool. And if you go to create ai tools, you will see the list of tools which create actually provides. They provide huge number of tools really. Yeah. Here you can see all the tools which create provides which you can use out of the box which means directly from you don't have to define any function for it. But here I have very simply tried to define a custom tool. So let's say you want to add one more tool which is a sentiment analysis tool. So essentially what you want to do is that when you draft the email you want the sentiment to be always positive. So the way you can ensure these things is that you can define your own tool over here. So from you do from create tools import base tool and then you define a class regarding the tool you want. So here I have defining sentiment analysis tool and I've kept it very simple. So for everything it will always return positive. But essentially what you can do is you can add an LLM here which classifies text into positive sentiment or negative sentiment. But it's very simple to define custom tools. You just have to define a new class and then you need to call an instance of that class to create a custom tool. Now someone was asking in the previous code how to add images right the way you can add images is that you can create a custom tool. So maybe you can say a class image creator tool. So here you can see that let's say if you want to add images along with your blog post in the previous right all you have to do is that you have to just say class image creation tool and you just mention the language model which you want over here to create that image and then this particular tool will be created for you for now I have just created a sentiment analysis tool which is going to essentially return positive uh for many descriptions which are there now um so So this is the custom tool which has been added after tools have been defined. So let's say you have the agents, you have the tools and then you have the tasks. Right? Now we come to the next pipeline which is defining the tasks. Um and this is where you have to make a distinction between agents and tasks. In agents we cannot write task but as you can see I'm going to define two tasks over here. The first task is the lead profiling task and that's the task of the first agent which is the sales rep agent. And the second task which I'm going to define is uh personalized outreach task. So this is where the email will be crafted and sent. So let's see how this task is defined. So lead profiling here right. Conduct an indepth analysis of lead name. A company in the industry sector that recently showed interest in our solutions. Utilize all available data sources to compile a detailed profile. This task is crucial for tailoring our engagement strategy. Now see the expected output. We want a comprehensive report on that particular lead including company background, key personal, recent milestones and needs. Highlight potential areas where our solutions can provide value. So this is the lead profile lead profiling task of the first agent which is the sales representative agent. The second task is where the email will be drafted. So using the insights gathered from the lead profiling report on this particular lead, craft a personalized outreach campaign aimed at the key decision maker, the position of that particular lead. The campaign should address their recent milestone and how our solutions can support their goals. So see that's what makes it personalized. Your communication must resonate with their company culture and values. And then the expected output is a series of personalized email drafts which are tailored to the lead name specifically targeting the key decision maker. Each draft should include a compelling narrative that connects our solutions with their recent achievements. Ensure that the tone is engaging, professional, and aligned with the lead name's corporate identity. See here again the prompt. The prompt engineering plays a very crucial role, right? Uh because you can simply write a oneliner prompt over here or you can simply mention two sentences but that won't make a difference at all. The more detailed the prompt you write the better it will work and that's the general advice for defining agents across any framework which we have seen so far. So this is the second task which has been defined and once the tasks have been defined once the agents have been defined we just create the crew. So you may be asking where are the tools over here right. So the tools are in the tasks. So if you see the first task is lead profiling and the tools have been defined over here to do the lead profiling I want to use the serper tool which is a web search tool directory read tool and a file read tool. And to make the personalized outreach task, I want to use two tools. I want to use the sererdev tool and I also want the sentiment analysis tool so that I can make sure that the email sentiment is generally positive. The email which is drafted. This is the place where you essentially create the crew and then as I mentioned the last step after the crew is created is kickoff this step. So here is where the crew takes off essentially the crew um starts starts to do its work. So here you can do the kicking of crew and we have to mention some input over here and this input can come from an excel sheet which your company maintains. So if in the Excel sheet you have deep learning AI which of course is Andre Wenji's platform and I if my company is CRAI and I want to form a partnership with deep learning AI I want to draft a customized email to Andreg and now my agents will work together with each other to draft this emailing. So first agent is a sales representative agent and you can see that it has understood its task. it will use. It also mentions the tools which you which it will use. So see the thought action observation is happening over here. This is the thought which the agent actually the agent thinks that to gather information about deep learning AI it would be best to start by searching the internet. That's the thought. The action is the agent decides to use the tool. So search the internet with serp. And what is it searching on serer?er it's searching deep learning AI company profile. So here's the deep learning company profile results which this agent has obtained. And here we can see that this looks correct because join over 7 million people learning how to use and build AI. It seems like something which might be written on this website which is deeplearning.ai. Yeah. See join over 7 million people learning how to use and build AI. And this is exactly what uh what we see over here. So the serper tool is scraping the data from this website. And uh that's the tool output of the first agent. But see again now this this agent entered one more loop. It does not stop here. So that's the thought action observation loop. Right? The search results have provided some important web pages related to deep learning AI uh which is their official website, LinkedIn profile and additional business information on crunchbase. These sources will be useful to extract specific data about the company's background. So then the tool which is used is read a files content and read that particular directory and then it will try to get directories at um different locations. So here we can see the thought action and observation and it's it's in a loop because still we are at the first agent we have not yet moved to the second agent. So the first agent is having multiple thought action observation loops over here. And then finally this is the answer by the first agent. So the first agent which is the sales representative collects an over overall background about the lead u the client whom we want to target and it passes on this information now this detailed report. It passes on this detailed report to the second agent and the second agent is the lead sales representative and the lead sales representative task is again using the insights gathered from the lead profiling craft a personalized outreach aimed at Andrew Wenji the CEO of deep learning AI and here you can see that the lead sales representative thinks here. So the thought is to create an outstanding personalized outreach campaign. I need to ensure that the initial communication draft reflects accurate and up-to-date information etc etc. Uh and then the tool is search the internet with serer etc. And then the lead sales representative has the final email based on all of this information and these are the multiple email drafts which it has made but it's a bit difficult to read. So what I've done is converted it to markdown below. So here you see I have three email drafts which can be directly sent to essentially Andrew WJI. So if I am a company who wants to target let's say potential clients. If such drafts are automatically ready for me, it will save a huge amount of time for me. And these drafts are not random drafts. They are completely personalized by agents scraping websites. um agents trying to personalize the content according to the company's profile etc. So what you see over here, dear Andreo, I hope this message finds you well. I greatly admire how deep learning AI has been pivotal. See now this information is got because in the prompt we mentioned that write about what that company is doing and align our mission with their mission. I greatly admire how deep learning AI has been pivotal in democratizing AI education with your recent initiatives. There is an apparent synergy between our missions at CRU. Our innovative AI platforms are tailored to supercharge engagement. Let's explore how we can collaborate. This is the first email. The second email is a bit more professional, I think, more concise. Your leadership is inspiring. At CUI, we believe in the power of collaboration. So, this highlights collaboration more. So, the first is new dimensions in AI learning. The second is enhancing deep learning collaborative tools. And the third email is a bit different. It's about drive data informed decisions at deep learning with CRA as analytics. So here we are pitching our analytic framework to them. So each email has a different content right and then you can choose which email you want to go ahead with. Uh so we can also add rag where agents can yeah essentially what you can do here you can take this a step further where if you have documents related to the client's company like if there are leads in an excel sheet and if you have documents explaining the company what you can do is that in the tools in the tools which you have over here you can also give uh the query engine as the tool loop and you can make this into an agent crack problem. But if you actually want to do agentic rag, I would suggest to use llama index. Llama index is perfectly suited for agent rag because it was originally conceived as an indexing package. Crei is ideally suited for assembling multiple agents together in a very easy manner and for building quick demonstrations. That's where CUI is very highly suitable for. So now here you can already see right if I want to draft an email I just copy this I paste it into my inbox and then I just edit it and send it and this is completely automated which means if I want to now do this for a new company I can just mention a new uh new inputs over here and then I can even make this into a loop 500 times,000 times etc and collect all the drafts into a report and then I can decide which drafts I can send etc. This framework is what many companies are actually looking out for. So there are many companies who are looking for people who can draft automate automated customer outreach campaigns for them and they are willing to pay for something like this. So if you are someone who can make this automated pipeline for the company uh which sets this outreach campaign for them, it does add value to their u process a lot because companies value two things, right? anything which increases revenue or anything which cuts down costs. So this will cut down costs because it saves time. Um okay so now how many of you actually got this result towards the end? Can you tell me and how many emails did each of you get? I got three emails over here. one email, right? So, actually nowhere did I explicitly mention three emails really. Um, I had just mentioned, so if you see over here, what I have mentioned is a series of personalized email drafts. So, this is a bit vague, right? I have mentioned the expected output is a series of personalized email draft. Now, series can mean one, two, three, it can even be more. And that's why there is a bit variability in the responses which all of us have received. Uh okay. So this let me pause here if there are any doubts or questions. This has brought us to the end of today's lecture but I'll take some questions in the chat. Can you please uh go over how to deploy agents? Yeah, that's a good question. So the agent deployment we are going to cover in tomorrow's lecture when we learn about NAN there are two ways to deploy agents actually you can deploy agents on the cloud or you can deploy agents directly on that particular uh provider. So let's say if you have let's say if you are using a coding framework let's say langraph llama index etc. You can deploy the application just like how you deploy any ML framework. You can upload the repository on GitHub. You can create a CI/CD pipeline. Uh you can track the metrics on ML flow or weights and biases etc. But if you are using uh platforms like NAN, it gives you two options of deployment. You can deploy on cloud um on your own, you can deploy on your own server also. Both options are possible. But if you use Python based frameworks like Langraph, Langchen etc. it's a py file py file ultimately. So it's very similar to the way you deploy other ML AI frameworks. The reason I showed you CUAI in Google Collab is ideally people run these frameworks in terminal but I specifically wanted to show in Google Collab so that my teaching becomes easier. If you want to develop this in production level workflows, you have to work in VS code. And not just that, one thing now I might suggest to all of you is how many of you have uh heard about this gemini live. Uh I think this is one of the biggest revolutions which has happened in coding in the last one or two weeks. I've used this and it's incredible. What it does is that if you are working on any code, right? Or if you're working on any uh project, you can download this. This sits in your uh this sits in your terminal and it's as if you have a junior development engineer working along with you. It automatically has access to all the code files. And by the way, it's an agent. So anyone who has used Google CLI now should try to relate some of the things which we have learned in this boot camp because this Gemini CLI when it sits in your terminal it automatically has access to all your root all your files in your root folder and it automatically goes to it automatically searches through the files etc. We don't have to specifically give it the context. Uh then claw code is also one more and uh of course cursor has been there for a long time but due to these new tools they are much easier alternatives than cursor so many people are thinking cursor's market share will now start to decrease but let's see when I tried gin clay I was amazed by it cla code is also one option but it's a bit expensive gemini cl is is like free um until a certain point. Yeah. Yeah. It's definitely better than GitHub pilot because it's extremely it's it feels like magic really if you use it geminina cloud or even cloud code I have tried cloud code also. So now if if if you are working on agentic projects right if you're working on a curi projects you should do it on your terminal and have gemini clst installed on your terminal itself. So it's as if you're working with a developer or a junior programmer. Uh okay, this is one thing. The second thing which I wanted to touch upon is Nvidia actually released the paper recently. Did you did any anyone of you see that paper? Uh so what they had actually mentioned was that agents become better with small language models. Yeah, I think it's this. Now, I really encourage all of you to read this paper because I think based on what all we have covered in this class, all of you will understand this paper. What these these people are saying and I think they make a very very good point is that when we create multiple agents, right? Like let's say right now we have created three agents. Uh we have created three agents over here. Right here we created a planner, a writer and an editor. And each of these agents is doing a very specific task. So why is it that we equip each of our agent with a very large language model with billions and trillions of parameters? Why do we equip every agent with 100 billion to 1 trillion let's say GPT 3.5 or whatever? Why can't it be possible that every agent is equipped with a small language model that has just 10 to 15 million parameters? Small language models are shown to be excellent at performing specific tasks and agents exactly do that. Agents perform a very specific task. For example, this planning agent is not going to tell me anything about finance. In this particular case, this planning agent is not going to tell me about sports news or other some random things. So why do I need an LLM which has all the knowledge in the world? It's like an overkill, right? It's like um expending unnecessary amount of compute. So this paper actually argues that when you have multiple agents assembled together and agents have access to tools, right? So every LLM which an agent has access to that can be a small language model. So what they have mentioned is that um the rise of agentic AI systems is ushering in a mass of applications in which language models perform a small number of specialized tasks. See this line is important small number of specialized tasks. Um so they have a proposition that SLMs are sufficiently powerful, more suitable and necessarily more economical for many invocations in agentic systems and are therefore the future of agentic AI and I actually completely agree with this. So SLM is more context specific and task specific but isn't aren't agents also exactly that when someone builds an agent it's usually for a specific task. It's not for doing all the things in the world. It's for a very specific task. So when companies want an agent, let's say they want an agent for um customer query handling, that's a very specific task and that can easily be done by a small language model who's trained at doing specific tasks. We don't need to invoke in giant models unnecessarily especially for agentic systems. And they kind of prove their point. They have their um they have their statements and they have some results also. So I think so if you can you can just read this paper. I'm going to post this as an assignment for the students who are on the pro plan. So this is going to be one final one of the final assignments uh which we have and I actually have a video on building a small language model from scratch. So if anyone of you is curious about how to build a small language model um I have recorded a three-hour video. this video. This is that video which will actually you how to build a small language model from scratch and I will uh share this on chat. If anyone is curious about what small language models are, this is something which you should definitely consider. Okay. And now that we have come to the end of this lecture, I want to mention that for people who are on the pro plan, there are three additional projects which I will be sharing on the GitHub repository. The first is multi- aent financial analysis using CUI, job application booster using CUAI and I will also be sharing a repository which evaluates CUI agents. These two are longer projects and they are a bit more deeper but I think now you'll understand how to do it exactly because the underlying framework is the same as what we have seen today. One thing I want to mention is this port key right so if you search about port key there is one Google collab notebook which actually lets you evaluate AI agents using or create ai agents using port key. So create can be connected with port key and you can actually evaluate how your agent is performing. So all these three I will add to the GitHub repo. There is one GitHub repo which I'm making for pro-registered participants which has five to six industrial projects. There I will also add a compilation of all our Substack articles etc. And finally tomorrow is going to be the last lecture. Um and that as I mentioned in the previous class that is going to be covered by Dr. Shridat who is one of our co-founders at Vijara and he also graduated with from MIT with the PhD he is going to cover NA basically he's going to cover NA he's going to cover MCP so you'll build multiple projects in NA tomorrow you'll build also an MCP project and we'll deploy this uh we'll also show the deployment using NAN and in tomorrow's lecture we'll also see a conclusion of what all we have seen so far. So I'll be present at the starting of tomorrow's lecture where I'll introduce Dr. Sridat and I'll also conclude related to everything which we have seen so far and the resources which I'll be providing next. So thanks everyone and I will look forward to seeing you in tomorrow's lecture. Tomorrow's lecture is where we'll again have AI automation projects as well. We'll build multiple AI automation projects um which then later you can add your port which you can add to your portfolio. Um thanks everyone. I look forward to seeing you in tomorrow's lecture which will be the last lecture of uh our boot camp. See you take care. Bye. And the timings will be same as today 2 p.m. IST. Bye.",
  "source": "https://youtu.be/jZ3koR7jzP0",
  "created_at": "2025-07-05T19:05:53.111060",
  "metadata": {
    "type": "youtube"
  }
}